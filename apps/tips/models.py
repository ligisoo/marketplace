from django.db import models
from django.conf import settings
from django.utils import timezone
from datetime import timedelta
import json


class Tip(models.Model):
    """Betting tip model with OCR support"""
    
    STATUS_CHOICES = [
        ('pending_approval', 'Pending Approval'),
        ('active', 'Active'),
        ('archived', 'Archived'),
        ('rejected', 'Rejected'),
    ]
    
    BOOKMAKER_CHOICES = [
        ('betika', 'Betika'),
        ('sportpesa', 'SportPesa'),
        ('betin', 'Betin'),
        ('mozzart', 'Mozzart'),
        ('odibets', 'Odibets'),
        ('other', 'Other'),
    ]
    
    # Basic tip information
    tipster = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='tips')
    bet_code = models.CharField(max_length=50, unique=True)
    bookmaker = models.CharField(max_length=20, choices=BOOKMAKER_CHOICES, default='betika')
    odds = models.DecimalField(max_digits=10, decimal_places=2)
    price = models.DecimalField(max_digits=8, decimal_places=2)
    
    # Screenshot and OCR data
    screenshot = models.ImageField(upload_to='betslips/', null=True, blank=True)
    bet_sharing_link = models.URLField(max_length=500, null=True, blank=True, help_text='SportPesa bet sharing/referral link')
    match_details = models.JSONField(default=dict, help_text='OCR extracted match details')
    preview_data = models.JSONField(default=dict, help_text='Preview data for buyers')
    
    # Status and timestamps
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending_approval')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    expires_at = models.DateTimeField(help_text='When tip expires (last match start time)')
    
    # OCR processing
    ocr_processed = models.BooleanField(default=False)
    ocr_confidence = models.DecimalField(max_digits=5, decimal_places=2, null=True, blank=True)

    # Background processing status
    PROCESSING_STATUS_CHOICES = [
        ('pending', 'Pending Processing'),
        ('processing', 'Processing'),
        ('completed', 'Processing Completed'),
        ('failed', 'Processing Failed'),
    ]
    processing_status = models.CharField(
        max_length=20,
        choices=PROCESSING_STATUS_CHOICES,
        default='completed',
        help_text='Status of background processing'
    )
    processing_error = models.TextField(null=True, blank=True, help_text='Error message if processing failed')
    enrichment_completed = models.BooleanField(default=False, help_text='Whether API-Football enrichment is complete')

    # Results tracking
    is_resulted = models.BooleanField(default=False)
    is_won = models.BooleanField(default=False)
    result_verified_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['status', 'created_at']),
            models.Index(fields=['tipster', 'status']),
            models.Index(fields=['expires_at']),
        ]
    
    def __str__(self):
        return f"{self.bet_code} - {self.tipster.userprofile.display_name}"
    
    @property
    def is_active(self):
        """Check if tip is currently active"""
        return self.status == 'active' and self.expires_at > timezone.now()
    
    @property
    def time_until_expiry(self):
        """Get time remaining until tip expires"""
        if self.expires_at > timezone.now():
            return self.expires_at - timezone.now()
        return timedelta(0)
    
    @property
    def purchase_count(self):
        """Get number of purchases for this tip"""
        return self.purchases.filter(status='completed').count()
    
    @property
    def revenue_generated(self):
        """Calculate total revenue generated by this tip"""
        return self.purchases.filter(status='completed').aggregate(
            total=models.Sum('amount')
        )['total'] or 0
    
    def get_preview_matches(self):
        """
        Get preview match information for buyers.
        Always hides at least one match to avoid giving away the entire tip.
        """
        matches = self.preview_data.get('matches', [])
        total_matches = self.preview_data.get('total_matches', len(matches))

        # Smart preview logic: never show all matches
        if total_matches == 1:
            return []  # Hide the only match
        elif total_matches == 2:
            return matches[:1]  # Show only first match, hide the second
        else:
            return matches[:2]  # Show first 2 matches for 3+ match betslips
    
    def can_be_purchased(self):
        """Check if tip can be purchased"""
        return (
            self.status == 'active' and 
            self.expires_at > timezone.now() and
            self.ocr_processed
        )
    
    def auto_archive_if_expired(self):
        """Automatically archive tip if expired"""
        if self.status == 'active' and self.expires_at <= timezone.now():
            self.status = 'archived'
            self.save(update_fields=['status', 'updated_at'])
            return True
        return False


class TipMatch(models.Model):
    """Individual match within a betting tip"""
    tip = models.ForeignKey(Tip, on_delete=models.CASCADE, related_name='matches')
    
    # Match information
    home_team = models.CharField(max_length=100)
    away_team = models.CharField(max_length=100)
    league = models.CharField(max_length=100, blank=True)
    match_date = models.DateTimeField()
    
    # Betting market
    market = models.CharField(max_length=100)  # e.g., "Over 2.5", "1X2", "Both Teams to Score"
    selection = models.CharField(max_length=100)  # e.g., "Over", "1", "Yes"
    odds = models.DecimalField(max_digits=6, decimal_places=2)
    
    # Result tracking
    is_resulted = models.BooleanField(default=False)
    is_won = models.BooleanField(default=False)
    actual_result = models.CharField(max_length=100, blank=True)
    
    # API tracking
    api_match_id = models.CharField(max_length=50, blank=True, help_text='API-Football match ID')
    
    class Meta:
        ordering = ['match_date']
    
    def __str__(self):
        return f"{self.home_team} vs {self.away_team} - {self.market}"


class TipPurchase(models.Model):
    """Purchase record for tips"""
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('refunded', 'Refunded'),
    ]
    
    tip = models.ForeignKey(Tip, on_delete=models.CASCADE, related_name='purchases')
    buyer = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='tip_purchases')
    amount = models.DecimalField(max_digits=8, decimal_places=2)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    
    # Payment details
    transaction_id = models.CharField(max_length=100, unique=True)
    mpesa_receipt = models.CharField(max_length=50, blank=True)
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        ordering = ['-created_at']
        unique_together = ['tip', 'buyer']  # One purchase per buyer per tip
    
    def __str__(self):
        return f"{self.buyer.userprofile.display_name} - {self.tip.bet_code}"


class TipView(models.Model):
    """Track tip views for analytics"""
    tip = models.ForeignKey(Tip, on_delete=models.CASCADE, related_name='views')
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, null=True, blank=True)
    ip_address = models.GenericIPAddressField()
    user_agent = models.TextField(blank=True)
    viewed_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-viewed_at']


class TipsterPayment(models.Model):
    """Track tipster payments for revenue earned from tip sales"""
    PAYMENT_STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('processing', 'Processing'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('cancelled', 'Cancelled'),
    ]

    PAYMENT_METHOD_CHOICES = [
        ('mpesa', 'M-Pesa'),
        ('bank_transfer', 'Bank Transfer'),
        ('paypal', 'PayPal'),
        ('other', 'Other'),
    ]

    # Tipster information
    tipster = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='payments_received'
    )

    # Payment period
    period_start = models.DateTimeField(help_text='Start of payment period')
    period_end = models.DateTimeField(help_text='End of payment period')

    # Financial details
    total_revenue = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        help_text='Total revenue from tip sales in this period'
    )
    platform_commission = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        default=40.00,
        help_text='Platform commission percentage (default: 40%)'
    )
    tipster_share = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        help_text='Amount to be paid to tipster (60% of revenue)'
    )

    # Payment details
    status = models.CharField(
        max_length=20,
        choices=PAYMENT_STATUS_CHOICES,
        default='pending'
    )
    payment_method = models.CharField(
        max_length=20,
        choices=PAYMENT_METHOD_CHOICES,
        blank=True
    )
    transaction_reference = models.CharField(
        max_length=100,
        blank=True,
        help_text='M-Pesa confirmation code or bank reference'
    )
    phone_number = models.CharField(
        max_length=15,
        blank=True,
        help_text='M-Pesa phone number'
    )

    # Metadata
    tips_count = models.IntegerField(
        default=0,
        help_text='Number of tips sold in this period'
    )
    purchases_count = models.IntegerField(
        default=0,
        help_text='Number of purchases in this period'
    )
    notes = models.TextField(blank=True, help_text='Payment notes or remarks')

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    paid_at = models.DateTimeField(null=True, blank=True)
    processed_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='payments_processed'
    )

    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['tipster', 'status']),
            models.Index(fields=['period_start', 'period_end']),
            models.Index(fields=['status', 'created_at']),
        ]
        verbose_name = 'Tipster Payment'
        verbose_name_plural = 'Tipster Payments'

    def __str__(self):
        return f"{self.tipster.userprofile.display_name} - KES {self.tipster_share} ({self.get_status_display()})"

    def save(self, *args, **kwargs):
        # Auto-calculate tipster share if not set
        if not self.tipster_share and self.total_revenue:
            commission_rate = self.platform_commission / 100
            self.tipster_share = self.total_revenue * (1 - commission_rate)
        super().save(*args, **kwargs)

    @property
    def platform_amount(self):
        """Calculate platform's share"""
        commission_rate = self.platform_commission / 100
        return self.total_revenue * commission_rate


class OCRProviderSettings(models.Model):
    """Settings for OCR provider selection"""
    OCR_PROVIDER_CHOICES = [
        ('textract', 'AWS Textract'),
        ('easyocr', 'EasyOCR'),
        ('sportpesa', 'SportPesa Scraper'),
    ]

    provider = models.CharField(
        max_length=20,
        choices=OCR_PROVIDER_CHOICES,
        default='textract',
        help_text='Select which OCR provider to use for processing betslips'
    )
    updated_at = models.DateTimeField(auto_now=True)
    updated_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='ocr_settings_updates'
    )

    class Meta:
        verbose_name = 'OCR Provider Setting'
        verbose_name_plural = 'OCR Provider Settings'

    def __str__(self):
        return f"OCR Provider: {self.get_provider_display()}"

    @classmethod
    def get_active_provider(cls):
        """Get the currently active OCR provider"""
        settings_obj = cls.objects.first()
        if settings_obj:
            return settings_obj.provider
        return 'textract'  # Default to Textract

    def save(self, *args, **kwargs):
        # Ensure only one settings record exists
        if not self.pk and OCRProviderSettings.objects.exists():
            # Update the existing record instead
            existing = OCRProviderSettings.objects.first()
            existing.provider = self.provider
            existing.updated_by = self.updated_by
            super(OCRProviderSettings, existing).save(*args, **kwargs)
        else:
            super().save(*args, **kwargs)
